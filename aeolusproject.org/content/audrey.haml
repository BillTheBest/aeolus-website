---
title: Aeolus Project - Audrey
area: projects
extension: html
filter:
  - haml
---
%h1 Audrey

.note
  %p
    %b REWRITTEN:
    Audrey configures instances in the cloud, after they have launched.

.page-listing
  %h3 Table of contents

  %ol
    %li
      %a{ :href => "#overview" } Overview

    %li
      %a{ :href => "#services" } Services

    %li
      %a{ :href => "#templates" } Templates

    %li
      %a{ :href => "#assemblies" } Assemblies

    %li
      %a{ :href => "#deployables" } Deployables

    %li
      %a{ :href => "#assemblydeps" } Assembly Dependencies in Deployables

    %li
      %a{ :href => "#components" } Components

    %li
      %a{ :href => "#integration" } Integration

%br

.section-grouping
  %h2(id="overview") Overview

  %p
    Audrey uses the information from <b>Templates</b>, <b>Assemblies</b>, and
    <b>Deployables</b> to build an <b>Instance Configuration</b> record for
    instances in a cloud.

  %p
    This <b>Instance Configuration</b> is used to generate the input to the
    specific <b>Configuration Engine</b> that will drive the post launch
    configuration.

%br

.section-grouping
  %h2(id="services") Services

  %img{ :src => "images/audrey_service.png", :width => "140",
        :height => "75", :alt => "Abstract Audrey image" }

  %p
    An Aeolus <b>Service</b> is an abstraction of something that can be
    configured by a <b>Configuration Engine</b>. Typically, a Service
    contains some static information along with parameters that can modify
    configuration of the service.

  %p
    For <a href="http://www.puppetlabs.com" title="Puppet website">Puppet</a>,
    this might be a collection of <b>Classes</b> and <b>Parameters</b>.  For
    <a href="http://wiki.opscode.com/display/chef/Home" title="Chef website">Chef</a>,
    this might be a <b>Chef Recipe</b>. A Service contains a set of
    <b>Parameters</b> that define how the service can be configured for an
    instance. Each parameter can be an input parameter, an output parameter,
    or both. The image above depicts a service with an input parameter and an
    output parameter.

  %p
    Input parameters are required by the service to function properly. Output
    parameters are provided by the service (or, provided by the configured
    instance).

  %p
    In order to build an Instance Configuration, values must be assigned to
    all input parameters.

%br

.section-grouping
  %h2(id="templates") Templates

  %img{ :src => "images/audrey_template.png", :width => "46",
        :height => "112", :alt => "Audrey template image" }

  %p
    An Aeolus <b>Template</b> describes a collection of services along with
    the operating system for an instance in a cloud.

  %p
    The image above depicts a Fedora template with several services. A
    template does not contain any values for the service parameters. Instead,
    it is a boilerplate representation of a class of instances. Additionally,
    it serves as the basis for creating images through
    <a href="imagefactory.html" title="Image Factory page">Image Factory</a>.

  %p
    The physical representation of a template is an XML file containing a
    <b>template name</b>, the <b>operating system</b>, a <b>description</b>,
    and a set of <b>services</b>.

  %h3 Example

  %p
    The example below shows how to specify a template that includes puppet
    classes and parameters.

  %table
    %caption
      %b Example 1:
      template.xml
    %tr
      %td
        %pre
          :preserve
            &lt;template name=&quot;Template1&quot; id=&quot;UUID&quot;&gt;
              &lt;os&gt;
                &lt;name&gt;Fedora&lt;/name&gt;
                &lt;version&gt;14&lt;/version&gt;
              &lt;/os&gt;
              &lt;description&gt;This is a template&lt;/description&gt;
              &lt;services&gt;
                &lt;service name=&quot;service-name&quot;&gt;
                  &lt;scripts&gt;
                    &lt;script&gt;puppet-class1&lt;/script&gt;
                    &lt;script&gt;puppet-class2&lt;/script&gt;
                  &lt;/scripts&gt;
                  &lt;!-- a parameter that must have a value in an assembly --&gt;
                  &lt;parameter name=&quot;param-name&quot; type=&quot;scalar&quot; required=&quot;true&quot;/&gt;
                  &lt;!-- a parameter whose value can be used by other assemblies in a deployable --&gt;
                  &lt;parameter name=&quot;param2-name&quot; type=&quot;scalar&quot; provided=&quot;true&quot;/&gt;
                &lt;/service&gt;
              &lt;/services&gt;
            &lt;/template&gt;

%br

.section-grouping
  %h2(id="assemblies") Assemblies

  %img{ :src => "images/audrey_assembly.png", :width => "63",
        :height => "112", :alt => "Audrey assembly image" }

  %p
    An Aeolus <b>Assembly</b> is really a template with values provided for
    the service parameters. These values are depicted as "<b>user data</b>" in
    the image above. The assembly represents the data required to configure a
    single instance in a cloud.

  %p
    An assembly is physically represented as an XML document with a name and
    a set of services. The name captures the assembly "<b>type</b>". An
    assembly type is a way of classifying the assembly for a particular
    purpose.

  %p
    For instance, there might be a "<b>mysql</b>" assembly type that indicates
    instances based on that assembly will be MySQL Database Servers.

  %h3(style="margin-bottom: 0.5em") Example

  %table
    %caption
      %b Example 2:
      assembly.xml
    %tr
      %td
        %pre
          :preserve
            &lt;assembly name="AssemblyType" id="UUID"&gt;
              &lt;template type="Template1" id="template-UUID/&gt;
              &lt;services&gt;
                &lt;service name="service-name"&gt;
                  &lt;parameter name="param-name"&gt;
                    &lt;value&gt;&lt;![CDATA[Parameter Value]]&gt;&lt;/value&gt;
                  &lt;/parameter&gt;
                  &lt;parameter name="another-parameter"&gt;
                    &lt;reference assembly="AnotherAssembly" provided-parameter="param-from-another-assembly"/&gt;
                  &lt;/parameter&gt;
                &lt;/service&gt;
              &lt;/services&gt;
            &lt;/assembly&gt;

%br

.section-grouping
  %h2(id="deployables") Deployables

  %img{ :src => "images/audrey_deployable.png", :width => "113",
        :height => "159", :alt => "Audrey deployable image" }

  %p
    An Aeolus <b>Deployable</b> is a logical grouping of assemblies to
    produce a complete "<b>system</b>"; where each assembly maps to a single
    instance in a cloud.

  %p
    For example, a deployable might contain an application server cluster
    (two or more "<b>app-server</b>" assemblies), a load balancer (a single
    "<b>apache load balancer</b>" assembly), and a database server (a single
    "<b>mysql</b>" assembly).

  %p
    The deployable XML format captures a list of assemblies. Each assembly
    referenced in the deployable contains three values: the assembly
    <b>type</b>, the assembly <b>name</b>, and the <b>hardware profile</b>
    for the instance.

  %p
    The assembly <b>type</b> references the assembly "<b>name</b>" from the
    assembly XML file. The assembly
    %b name
    in the deployable is a unique name for that instance of the assembly in
    this deployable. The
    %b hardware profile
    indicates what size/type of virtual machine should be used when creating
    the instance in the cloud.

  %h3(style="margin-bottom: 0.5em") Example

  %table
    %caption
      %b Example 3:
      deployable.xml
    %tr
      %td
        %pre
          :preserve
            &lt;deployable name=&quot;Deployable1&quot;&gt;
              &lt;assemblies&gt;
                &lt;assembly name=&quot;FirstAssembly&quot; type=&quot;AssemblyType&quot; hwp=&quot;large&quot;/&gt;
                &lt;assembly name=&quot;SecondAssembly&quot; type=&quot;AssemblyType&quot; hwp=&quot;large&quot;/&gt;
              &lt;/assemblies&gt;
            &lt;/deployable&gt;

%br

.section-grouping
  %h2(id="assemblydeps") Assembly Dependencies in Deployables

  %p
    The assemblies in a deployable often need to share information in order
    to be fully configured.

  %p
    For instance, a database server might need to share connection
    information with application servers. This is handled through one
    assembly consuming the output parameter of another assembly.

  %p
    There are several models of implementing this type of dependency. Since
    an output parameter is scoped to a service in an assembly, there are at
    least three ways to model this relationship.

  %h3 Assembly Name and Parameter Name

  %p
    In this scenario, one assembly specifically calls out another assembly by
    name and refers to a parameter in that assembly.

  %p
    For example:

  %table
    %caption
      %b Example 4:
      Assembly dependency by assembly name
    %tr
      %td
        %pre
          :preserve
            &lt;assembly name=&quot;name&quot;&gt;
              ...
                &lt;parameter name=&quot;param-name&quot;&gt;
                  &lt;reference assembly=&quot;another-assembly-name&quot; provided-parameter=&quot;param-from-another-assembly&quot;/&gt;
                &lt;/parameter&gt;
              ...
            &lt;/assembly&gt;

  %p
    When referencing the assembly name directly
    ("<b>another-assembly-name</b>"), the value pulled in for this parameter
    is guaranteed to come from one specific assembly. In other words, this is
    one instance depending on a value from another single specific instance.
    Or, a one-to-one relationship.

  %h3 Assembly Type and Parameter Name

  %p
    Referencing an external parameter by assembly type raises a separate
    question of, "<b>Do you want the parameter value from all matching
    assemblies in the deployable?</b>".

  %p
    For instance, this relationship could be captured by the following example:

  %table
    %caption
      %b Example 5:
      Assembly dependency by assembly type (unrestricted)
    %tr
      %td
        %pre
          :preserve
            &lt;assembly name=&quot;name&quot;&gt;
              ...
                &lt;parameter name=&quot;param-name&quot;&gt;
                  &lt;reference assembly-type=&quot;AssemblyType&quot; provided-parameter=&quot;param-from-assembly-type&quot;/&gt;
                &lt;/parameter&gt;
              ...
            &lt;/assembly&gt;

  %p
    In this scenario, it is assumed that all assemblies of type
    "<b>AssemblyType</b>" in the deployable could provide this value and that
    the scripts for the configuration engine that execute on the instance can
    deal with a list of data for the value of "param-name".

  %p
    However, it's possible that the goal of this usage is to acquire the
    first matching value for "<b>param-from-assembly-type</b>" from any
    assembly of type "<b>AssemblyType</b>" in the deployable. In that case,
    the relationship might look more like:

  %table
    %caption
      %b Example 6:
      Assembly dependency by assembly type (restricted)
    %tr
      %td
        %pre
          :preserve
            &lt;assembly name=&quot;name&quot;&gt;
              ...
                &lt;parameter name=&quot;param-name&quot;&gt;
                  &lt;reference assembly-type=&quot;AssemblyType&quot; match-type=&quot;first&quot; provided-parameter=&quot;param-from-assembly-type&quot;/&gt;
                &lt;/parameter&gt;
              ...
            &lt;/assembly&gt;

  %p
    In this example, the reference element specifically calls out that it
    only wants the first one that reports a value. It's dubious whether this
    could actually be useful, since it is entirely unpredictable which
    instance in the deployable will be the first to report a value.

  %h3 Service Name and Parameter Name

  %p
    This is similar to the previous example, but even less restrictive.

  %p
    Instead of asking for all values (or, one value) from a specific assembly
    type, this example asks for all values (or, one value) from a service.
    And, since a service name is not bound to any assembly type, the service
    could exist in many different types of assemblies in a deployable.  This
    relationship might look like:

  %table
    %caption
      %b Example 7:
      Assembly dependency by service name (unrestricted)
    %tr
      %td
        %pre
          :preserve
            &lt;assembly name=&quot;name&quot;&gt;
              ...
                &lt;parameter name=&quot;param-name&quot;&gt;
                  &lt;reference service=&quot;service-name&quot; provided-parameter=&quot;param-from-service&quot;/&gt;
                &lt;/parameter&gt;
              ...
            &lt;/assembly&gt;

  %p
    Similar to the previous example of referencing an assembly type, the
    question of "<b>Do you want the parameter value from all matching services
    in the deployable?</b>". If the answer is no, then perhaps the
    relationship could be extended to include a match-type:

  %table
    %caption
      %b Example 8:
      Assembly dependency by service name (restricted)
    %tr
      %td
        %pre
          :preserve
            &lt;assembly name=&quot;name&quot;&gt;
              ...
                &lt;parameter name=&quot;param-name&quot;&gt;
                  &lt;reference service=&quot;service-name&quot; match-type=&quot;first&quot; provided-parameter=&quot;param-from-service&quot;/&gt;
                &lt;/parameter&gt;
              ...
            &lt;/assembly&gt;

%br

.section-grouping
  %h2(id="components") Components

  %p
    Audrey is not a single piece of infrastructure. Instead, it is several
    components spread throughout Aeolus. The diagram below depicts the
    various pieces of Audrey that exist in the workflow of spinning up
    instances in a cloud.

  %table(id="figure1")
    %caption
      %b Figure 1:
      Audrey overview
    %tr
      %td
        %img{ :src => "images/audrey_overview.png", :width => "800",
          :height => "594", :alt => "Audrey deployable image" }

  %p
    There are several moving parts in Figure 1 above:

  %table.team-table(id="table1" width="80%")
    %caption
      %b Table 1:
      Audrey overview breakdown
    %thead
      %tr
        %td
          %b Deployable
        %td(style="text-align: left") The collection of assemblies that will generate instances in a cloud
    %tbody
      %tr
        %td
          %b Cloud Engine
        %td(style="text-align: left") A collection of tools in Aeolus that work together to generate instances in various cloud providers
      %tr
        %td
          %b Cloud
        %td(style="text-align: left") A cloud provider
      %tr
        %td
          %b Config Server
        %td(style="text-align: left") A piece of Audrey that manages the instance configuration data
      %tr
        %td
          %b Instance
        %td(style="text-align: left") The actual instance in a cloud, created by Cloud Engine
    %tfoot
      %tr
        %td(style="font: normal 12px Verdana, Arial, Helvetica")
          %b Audrey Startup
        %td(style="text-align: left") The Audrey component that resides on the instance, which contacts the Config Server for configuration information

  %p
    The process follows the diagram from the top left to the bottom right.  A
    deployable is fed to Cloud Engine, which creates the instance for a cloud
    provider and generates the "<b>instance configuration</b>" data to post
    to the Config Server.  As the instances start up in the cloud, the Audrey
    Startup script--the Audrey component in the instance--is instructed to
    "phone home" to the same Config Server that received the
    "instance configuration" data.  The Config Server then sends down
    configuration information to the instance so that it might configure
    itself.

  %h3 Instance Configuration Generation (Conductor)

  %p
    To generate the instance configuration, the Cloud Engine relies on
    Conductor to process the deployable and produce data that can be consumed
    by the Config Server. This "instance configuration" is an XML file that
    captures the slice of the deployable that is relevant to a single
    instance.  Essentially, this amounts to:

  %ul
    %li Template
    %li Assembly with "user data"
    %li Deployable name
    %li Deployable UUID (generated by Conductor)
    %li Instance UUID (generated by Conductor)

  %h4 Example Instance Configuration

  %p
    This example instance configuration shows puppet classes and parameters
    that will be included in an instance's configuration information.

  %table
    %caption
      %b Example 9:
      instance-config.xml
    %tr
      %td
        %pre
          :preserve
            &lt;instance-config id=&quot;INSTANCE_UUID&quot; type=&quot;AssemblyType&quot; name=&quot;AssemblyName&quot;&gt;
              &lt;deployable name=&quot;DeployableName&quot; id=&quot;DEPLOYABLE_UUID&quot;/&gt;
              &lt;template name=&quot;TemplateName&quot;/&gt;
              &lt;provided-parameters&gt;
                &lt;provided-parameter name=&quot;param-name&quot;/&gt;
              &lt;/provided-parameters&gt;
              &lt;services&gt;
                &lt;service name=&quot;service-name&quot;&gt;
                  &lt;scripts&gt;
                    &lt;script name=&quot;puppet-class-name&quot;/&gt;
                    &lt;script name=&quot;puppet-class-name&quot;/&gt;
                  &lt;/scripts&gt;
                  &lt;parameter name=&quot;param1-name&quot;&gt;
                    &lt;value&gt;&lt;![CDATA[Param1 Value]]&gt;&lt;/value&gt;
                  &lt;/parameter&gt;
                  &lt;parameter name=&quot;param2-name&quot;&gt;
                    &lt;reference assembly=&quot;Assembly2Name&quot; provided-parameter=&quot;parameter-from-assembly2&quot;/&gt;
                  &lt;/parameter&gt;
                &lt;/service&gt;
              &lt;/services&gt;
            &lt;/instance-config&gt;

  %h4 Config Server

  %p
    The Config Server handles providing the configuration information to
    instances as they ask for it. This configuration information is a
    configuration engine agnostic format that the Audrey Startup script on
    the instance knows how to parse and produce configuration engine specific
    input.

  %p
    The diagram below shows the overview of interacting with the Config
    Server:

  %table
    %caption
      %b Figure 2:
      Audrey Config Server
    %tr
      %td
        %img{ :src => "images/audrey_config_server.png", :width => "800",
          :height => "546", :alt => "RHEV-M image" }

  %p
    Figure 2 shows the specific interactions with the Config Server and cuts out much of what is happening in the Cloud Engine. For the Config Server to provide complete configuration data to an instance, several things take place:

  %table.team-table(id="table2" width="80%")
    %caption
      %b Table 2:
      Config Server communication process
    %thead
      %tr
        %td(width="5%") Step #
        %td(style="text-align: left") Description
    %tbody
      %tr
        %td
          %b 1
        %td(style="text-align: left")
          Conductor POSTs instance configuration to the Config Server
      %tr
        %td
          %b 2
        %td(style="text-align: left")
          The Audrey Startup script on the Instance "learns" how to contact
          the Config Server (not shown--see
          %a(href="#audrey-startup") Audrey Startup 
          below)
      %tr
        %td
          %b 3
        %td(style="text-align: left")
          The Audrey Startup script issues a GET for the configuration data
      %tr
        %td
          %b 4
        %td(style="white-space: normal; text-align: left")
          The Audrey Startup script issues a GET for the parameters that the
          Config Server expects the instance to provide back (the
          "provided-parameters" section from the instance-config XML document)
    %tfoot
      %tr
        %td(style="font: normal 12px Verdana, Arial, Helvetica")
          %b 5
        %td(style="text-align: left")
          The Audrey Startup script issues a PUT to send the
          "provided-parameters" values back to the Config Server.

  %h4(id="restful-interface") RESTful Interface

  %p
    For the different types of requests to the Config Server, there are a set of specific responses that can occur.

  %table.team-table(id="table3" width="80%")
    %caption
      %b Table 3:
      RESTful interface for config server
    %thead
      %tr
        %td(width="20%") Request
        %td(width="8%") Status
        %td(style="text-align: left") Description
    %tbody
      %tr
        %td(rowspan="2")
          %b POST /configs/$UUID
        %td 201
        %td(style="text-align: left")
          The instance configuration document was received and a record was
          created for the instance
      %tr
        %td 400
        %td(style="text-align: left")
          The instance configuration document is not valid
      %tr
        %td(rowspan="3")
          %b GET /configs/$UUID
        %td 200
        %td(style="white-space: normal; text-align: left")
          The complete set of instance configs is returned in the response
          body. There's no need to request again.
      %tr
        %td 202
        %td(style="white-space: normal; text-align: left")
          The response body contains a portion of the complete set of
          instance configs. Try again soon for the complete set.
      %tr
        %td 404
        %td(style="text-align: left")
          The requested URL cannot be found.
      %tr
        %td(rowspan="3")
          %b GET /params/$UUID
        %td 200
        %td(style="text-align: left")
          The config server does not require anymore provided parameters from
          the instance.
      %tr
        %td 202
        %td(style="text-align: left")
          The response body contains the set of provided parameters still
          required by the config server.
      %tr
        %td 404
        %td(style="text-align: left")
          The requested URL cannot be found.
    %tfoot
      %tr
        %td(rowspan="2" style="font: normal 12px Verdana, Arial, Helvetica")
          %b PUT /reply/$UUID
        %td(style="border-bottom-left-radius: 0; border-bottom-right-radius: 0")
          200
        %td(style="text-align: left; border-bottom-left-radius: 0; border-bottom-right-radius: 0")
          The values for the provided params in the request body have been
          updated for $UUID.
      %tr
        %td 404
        %td(style="text-align: left")
          The $UUID in the request is not known by the config server.

  %h4 Partial Configuration

  %p
    Since there is no way for the Config Server to predetermine which
    instance will be the first to execute the PUT (Table 2, step 5), assembly
    dependencies are not guaranteed to be fulfilled before an instance does
    the first GET (Table 2, step 3). For example, if Assembly1 depends on
    provided parameters from Assembly2, but Assembly1 does its GET (Table 2,
    step 3) before Assembly2 does its PUT (Table 2, step 5), then the
    configurations available to Assembly1 will be incomplete.

  %p
    There is a choice to make in this situation: allow partial configs to be
    sent to instance, or do not allow partial configs? The best way to handle
    this choice is probably to make it configurable either at the assembly
    level or the service level.

  %p
    If an instance is not allowed to partially configure, then the Config
    Server will respond to step 3 with an empty response body and an HTTP 202
    status code.  This will indicate to the client that even though the body
    is empty, there really is configuration data to retrieve, and the client
    should try again later.  If the instance is allowed to partially
    configure, then the Config Server will still respond with an HTTP 202
    status code, but the response body will contain whatever configuration
    data can be collected at the time of the request.

  %p
    If a client receives an HTTP 202 status code, it is up to the client to
    understand how to configure itself based on the partial configuration
    data.

  %h4 Deadlock Concerns

  %p
    Since this system of assembly dependencies generates instances that
    depend on each other for configuration information, it's possible to
    construct a set of dependencies that lead to deadlock.  In other words,
    it's possible to have assembly dependencies that lead to instances never
    being able to finish their configuration because they are forever waiting
    for other instances to report "provided" parameters.

  %table
    %caption
      %b Figure 3:
      Audrey deadlock example
    %tr
      %td
        %img{ :src => "images/audrey_deadlock.png", :width => "367",
          :height => "167", :alt => "RHEV-M image" }

  %p
    Figure 3 illustrates a contrived deadlock example.  When configured,
    service "B" in Assembly1 produces a parameter that is required by service
    "2" in Assembly2.  Service "2" produces a parameter that is required by
    service "Y" in Assembly3.  And, service "Y" produces a parameter that is
    required by service "B" in Assembly1.  In order for any of those three
    services to be configured, another service in another instance must first
    be configured.  In this example, services "B", "2", and "Y" will never be
    able to complete configuration.

  %p
    There are no immediate plans to have Audrey do deadlock detection.  It is
    up to the configuration engine script author to determine that the
    service and assembly dependencies in a deployable do not cause deadlock.

  %h3(id="audrey-startup") Audrey Startup

  %p
    %b TODO:
    %i Include link to Audrey Start documentation

  %p
    Each instance that is part of an Aeolus deployable must be created from
    an image that contains the Audrey Start script.  The Audrey Start script
    depends on the '''user data''' from the Assembly to indicate where the
    Config Server can be found.  The ''user data'' also contains the UUID for
    the instance, which is used in requests from the instance to retrieve
    configuration data from the Config Server (see
    <a href="#restful-interface" title="RESTful Interface">RESTful Interface</a>).

%br

.section-grouping
  %h2(id="integration") Integration

  %h3(id="ce-integration") Cloud Engine Integration

  %p
    The integration with Cloud Engine is limited to requiring images to
    contain the Audrey Start script when creating Audrey-enabled instances.
    To that end, the proper Audrey client tools packages need to be part of
    the Template used by Image Factory when creating images.

  %h3 Cloud Provider Integration

  %p
    Audrey's main purpose is to enable post boot configuration of instances
    in a cloud.  To that end, it is important that Audrey supports various
    cloud providers.

  %p
    For the initial reference implementation, only EC2 is included for
    integration.

  %h4 EC2

  %p
    Integrating with EC2 amounts to three items:

  %ul
    %li Setting up a Config Server in EC2
    %li
      %a(href="#ce-integration") Cloud Engine integration
    %li Properly creating <b>user data</b> in EC2's user data location

  %p
    Setting up a Config Server in EC2 is largely a manual process today.  It
    entails creating a new instance through the AWS console, installing the
    <b>aeolus-configserver</b> package, and configuring the Config Server
    appropriately.  It is the goal of the Audrey development team to create a
    streamlined process for creating Config Servers for EC2.

  %p
    The Cloud Engine integration simply assures that instances created as
    part of a deployable in EC2 have the correct Audrey Start script
    installed.

  %p
    Properly creating the <b>user data</b> in EC2's user data location simply
    requires using Cloud Engine to create the instances for EC2.  This
    ensures the correct EC2 deltacloud driver will be used when the user data
    is created for the instance.

  %h4 RHEV-M

  %p
    Integration with RHEV-M adds an extra bit of complexity over integrating
    with EC2.  The EC2 deltacloud back-end driver can query EC2 as a cloud
    provider and request the IP address of instances it has launched.
    RHEV-M doesn't have this same support.  In order to return IP addresses
    to the RHEV-M deltacloud back-end driver, the driver needs to ask the
    Config Server responsible for the configuration management of launched
    instances.

  %p
    As instances are launched, they contact the Config Server via HTTP (see
    <a href="#figure1">Figure 1</a> above).  The config server stores the IP
    address of the instances as they check in.  This information can be
    retrieved by another REST call to the config server.
    <a href="#figure4">Figure 4</a> below illustrates this extra integration
    point.

  %table(id="figure4")
    %caption
      %b Figure 4:
      Audrey RHEV-M Integration
    %tr
      %td
        %img{ :src => "images/audrey_rhev_m.png", :width => "800",
          :height => "594", :alt => "RHEV-M image" }

  -# TODO
  -#%h3 Security

  -# TODO
  -# %h4 Identity, Policy, and Audit (IPA)
