
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <title>Deltacloud - Documentation</title>



  <meta name="keywords" content="">
  <meta name="description" content="">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="shortcut icon" href="./styles/favicon.ico" type="image/x-icon">
  <link rel="StyleSheet" type="text/css" href="./styles/default.css" title="Main style">

  <link rel="Alternate StyleSheet" type="text/css" href="./styles/default-debug.css" title="Debug main style">

</head>


<body>
  <div id="header">
       <div class="container">
       <div id="headerLogo" style="cursor: pointer;" onclick="location.href='index.html';">
       <h1>Deltacloud - Many clouds. One API. No problem.</h1>
       </div>

       </div>
  </div>

    <div id="navigation">

    <div id="menu" class="container">
      <ul class="l0">
               <li><a class="inactive" title="Deltacloud Home" href="./index.html">Home</a></li>
               <li><a class="inactive" title="Tools" href="./tools.html">Tools</a></li>
               <li><a class="inactive" title="Get the latest releases" href="./download.html">Download</a></li>
               <li><a class="inactive" title="Information about design/development process" href="./contribute.html">Contribute</a></li>
               <li><a class="active" title="Project documentation" href="./documentation.html">Documentation</a></li>
               <li><a class="inactive" title="Project wiki" href="./page">Wiki</a></li>
         </ul>

    </div>
    </div>
       <div id ="subnavigation">
       <div id="submenu" class="container">

          <ul class="l1">
<li>
  <a class="inactive" href="documentation.html">Overview</a>
</li>
<li>
  <a class="inactive" href="api.html">REST API</a>
</li>
<li>
  <a class="inactive" href="client-ruby.html">Ruby Client</a>
</li>
<li>
  <a class="inactive" href="drivers.html">Drivers</a>
</li>
<li>
  <a class="active" href="framework.html">Framework</a>
</li>
</ul>

       </div>
       </div>

       <div id="main">
    <div id="content-deltacloud" class="container">
      <ul class="toc">
  <li><a href="#driver_spi">Driver SPI</a>
    <ul>
  <li><a href="#driver_spi_credentials">Credentials</a>
  <li><a href="#driver_spi_object_models_used_by_drivers">Object models used by drivers</a>
  <li><a href="#driver_spi_driver_methods">Driver methods</a>
    </ul>
  </li>
</ul>
<h1>Deltacloud Framework (Ruby)</h1>

<p>The <em>Deltacloud Framework</em> is provided to assist in creating
intermediary <a href="drivers.html">drivers</a> which speak the <a href="api.html">Deltacloud REST API</a> on
the front while communicating with cloud providers using
their own native APIs on the back.</p>

<p><img src="styles/framework.png" alt="Deltacloud framework" /></p>

<p>The Deltacloud Framework handles all aspects of the REST
API, while allowing driver implementors to focus on the
specific cloud provider native API.</p>

<p>The framework is implemented as a Ruby-on-Rails application.
Drivers may be implemented in as little as one Ruby class
and plugged into the framework for deployment.</p>

<h2><a name="driver_spi">Driver SPI</a></h2>

<h3><a name="driver_spi_credentials">Credentials</a></h3>

<p>The framework will collect credentials when the driver indicates
they are required by throwing a <code>DeltaCloud::AuthException</code>.  Each
driver method takes a credentials hash as the first parameter,
but unless the client has provided credentials, this hash will be empty.</p>

<pre><code>def images(credentials, opts)
  if ( credentials[:name].nil? )
    throw DeltaCloud::AuthException.new
  end
  unless ( credentials_valid?( credentials ) )
    throw DeltaCloud::AuthException.new
  end

  # do work

end
</code></pre>

<h3><a name="driver_spi_object_models_used_by_drivers">Object models used by drivers</a></h3>

<p>To assist driver authors, the framework provides a handful of
model classes, representing each resource available through
the Deltacloud API.  Please see the <a href="api.html">API reference</a> for details
about each model.  All of these model objects may be initialized
with a hash.  Every instance <em>must</em> be assigned an <code>id</code> in addition
to other attributes it may have.  Unless otherwise noted, attributes
are text.</p>

<p>For example</p>

<pre><code>Flavor.new(
  :architecture=&gt;'x86_64',
  :memory=&gt;4,
  :storage=&gt;650,
)
</code></pre>

<h4><code>Flavor</code> (<code>app/models/flavor.rb</code>)</h4>

<p>Attributes are</p>

<ul>
<li><strong><code>id</code></strong></li>
<li><strong><code>architecture</code></strong></li>
<li><strong><code>memory</code></strong> - Decimal, gigabytes</li>
<li><strong><code>storage</code></strong> - Decimal, gigabytes</li>
</ul>

<h4><code>Realm</code> (<code>app/models/realm.rb</code>)</h4>

<p>Attributes are</p>

<ul>
<li><strong><code>id</code></strong></li>
<li><strong><code>name</code></strong></li>
<li><strong><code>state</code></strong></li>
<li><strong><code>limit</code></strong></li>
</ul>

<h4><code>Image</code> (<code>app/models/image.rb</code>)</h4>

<p>Attributes are</p>

<ul>
<li><strong><code>id</code></strong></li>
<li><strong><code>name</code></strong></li>
<li><strong><code>architecture</code></strong></li>
<li><strong><code>owner_id</code></strong></li>
<li><strong><code>description</code></strong></li>
</ul>

<h4><code>Instance</code> (<code>app/models/instance.rb</code>)</h4>

<p>Attributes are</p>

<ul>
<li><strong><code>id</code></strong></li>
<li><strong><code>name</code></strong></li>
<li><strong><code>owner_id</code></strong> - Opaque, external reference</li>
<li><strong><code>image_id</code></strong> - References an image by identifier</li>
<li><strong><code>flavor_id</code></strong> - References a flavor image by identifier</li>
<li><strong><code>realm_id</code></strong> - References a realm by identifier</li>
<li><strong><code>state</code></strong> - One of <code>PENDING</code>, <code>RUNNING</code>, 'SHUTTING_DOWN', 'STOPPED'</li>
<li><strong><code>actions</code></strong> - Array of applicable actions</li>
<li><strong><code>public_addresses</code></strong> - Array of IP addresses or hostnames as text</li>
<li><strong><code>private_addresses</code></strong> - Array of IP addresses or hostnames as text</li>
</ul>

<h3><a name="driver_spi_driver_methods">Driver methods</a></h3>

<p>The primary methods a driver class must implement are</p>

<ul>
<li><code>flavors(credentials, opts=nil)</code></li>
<li><code>images(credentials, opts=nil )</code></li>
<li><code>realms(credentials, opts=nil)</code></li>
<li><code>instances(credentials, opts=nil)</code></li>
<li><code>create_instance(credentials, image_id, opts)</code></li>
<li><code>reboot_instance(credentials, id)</code></li>
<li><code>stop_instance(credentials, id)</code></li>
<li><code>destroy_instance(credentials, id)</code></li>
</ul>

<p>Generally, the <code>BaseDriver</code> handles singular cases while the
specific provider driver must implement only the plural cases,
along with specific action methods against resources.</p>

<p>Additionally, to assist clients in determining what actions
may be available without making additional requests, the following
must be implemented.</p>

<p>While the <code>credentials</code> hash is passed as the first parameter to each
method, it <em>may</em> be empty until the driver throws at least one
<code>DeltaCloud::AuthException</code>. This exception will indicate to the
framework that a normal HTTP authentication challenge should be
issued to the client.  Depending on the underlying provider the driver
is connecting to, the credentials may not be required for some methods.</p>

<p>Some methods also allow an optional <code>opts</code> hash, which may be <code>nil</code> or
empty if not used for a particular invocation.  The <code>BaseDriver</code> provides
a method <code>filter_on(...)</code> which may be used to safely filter collections.
The <code>filter_on(..)</code> method will be demonstrated below.</p>

<ul>
<li><code>instance_states()</code></li>
</ul>

<p>Each method will be described in more detail below.</p>

<h4><code>flavors(credentials, opts=nil)</code></h4>

<p>The <code>flavors(...)</code> method should return an array of <code>Flavor</code> objects.
The <code>opts</code> hash, if present, must be inspected for <code>:id</code> and <code>:architecture</code>
keys.  If these keys are present, the results should be filtered by the value
associated with each key.  The <code>filter_on(...)</code> method is useful in this case.</p>

<p>For example</p>

<pre><code>def flavors(credentials, opts=nil)
  flavors = fetch_all_flavors()
  flavors = filter_on( flavors, :id, opts )
  flavors = filter_on( flavors, :architecture, opts )
  return flavors
end
</code></pre>

<h4><code>realms(credentials, opts=nil)</code></h4>

<p>The <code>realms(...)</code> method should return an array of <code>Realm</code> objects.</p>

<h4><code>images(credentials, opts=nil )</code></h4>

<p>The <code>images(...)</code> method should return an array of <code>Image</code> objects
visible and accessible to the current user, as defined by the <code>credentials</code>
hash.</p>

<p>The <code>opts</code> hash, if present, must be inspected for <code>:id</code>, <code>:owner_id</code>
and <code>:architecture</code> keys.  If these keys are present, the results should be filtered
by the value assocaited with each key.</p>

<h4><code>instances(credentials, opts=nil)</code></h4>

<p>The <code>instances(...)</code> method should return an array of <code>Instance</code> objects
visible and accessible to the current user, as defined bv the <code>credentials</code>
hash.  If the <code>opts</code> hash is present and contains an <code>:id</code> key, the results
should be filtered by the value associated with the key.</p>

<h4><code>create_instance(credentials, image_id, opts)</code></h4>

<p>The <code>create_instance(...)</code> method should create within the cloud, a new
running instance based from an image identifier.  The method should return
an <code>Instance</code> object representing the newly-created instance.</p>

<p>The <code>image_id</code> parameter must be non-nil.  The <code>opts</code> has may contain keys
for <code>flavor_id</code> and <code>realm_id</code>.  If they are present, they should be used
for the creation of the instance.  If they are not present, reasonable
defaults should be used. In the case of flavor, one compatible with the
image should be used as the default.  </p>

<h4><code>reboot_instance(credentials, id)</code></h4>

<p>The <code>reboot_instance(...)</code> method should trigger a running instance to be
rebooted.  This method has no return value.</p>

<h4><code>stop_instance(credentials, id)</code></h4>

<p>The <code>stop_instance(...)</code> method should trigger a running instance to be
stopped.  This method has no return value.  A cloud provider may allow
restarting an instance, or may not.</p>

<h4><code>destroy_instance(credentials, id)</code></h4>

<p>The <code>destroy_instance(...)</code> method should remove the instance from the
cloud provider, stopping it if necessary first.</p>

<h4><code>instance_states()</code></h4>

<p>The <code>instance_states()</code> method should return an complex array/hash
structure representing the finite-state-machine for instances.
Each state an instance may be in should be an element in the returned array.
Each state itself is also an array with 2 member.  The first member is the
name of the state, and the second member is a hash indicating valid transitions.</p>

<p>The general format for the entire FSM structure is</p>

<pre><code>[
  [ :origin_state1, {
    :destination_state1=&gt;:action1,
    :destination_state2=&gt;:action2,
  } ],
  [ :origin_state2, {
    :destination_state3=&gt;:action3,
    :destination_state4=&gt;:action4,
  } ],
]
</code></pre>

<p>Valid states are</p>

<ul>
<li><strong><code>:begin</code></strong></li>
<li><strong><code>:pending</code></strong></li>
<li><strong><code>:running</code></strong></li>
<li><strong><code>:shutting_down</code></strong></li>
<li><strong><code>:stopped</code></strong></li>
<li><strong><code>:end</code></strong></li>
</ul>

<p>The <code>:begin</code> state is the state an instance is in immediate before
being created.  The <code>:end</code> state is the state an instance is in immediately
after being destroyed.</p>

<p>Valid transition actions are</p>

<ul>
<li><strong><code>:stop</code></strong></li>
<li><strong><code>:start</code></strong></li>
<li><strong><code>:reboot</code></strong></li>
</ul>

<p>Additionally, to indicate a transition that may occur <em>without</em> an
action being triggered, the action **<code>:_auto_</code> may be used.</p>

    </div>
  </div>

  <div id="footer-deltacloud">
    <div id="projects" class="container">
       <p id="et">
      <a href="http://et.redhat.com/"><img src="./styles/et_logo.png" alt="A Red Hat Emerging Technology Project"></a>

    </p>
      <dl id="p1">
        <dt><a href="http://augeas.net/">Augeas</a></dt>

        <dd><span>A configuration editing tool and API</span></dd>
        <dt><a href="http://libvirt.org/">libvirt</a></dt>
        <dd><span>The open source virtualization API</span></dd>
      </dl>

      <dl id="p2">
        <dt><a href="http://cobbler.et.redhat.com/">Cobbler</a></dt>

        <dd>OS provisioning and profile management</dd>
        <dt><a href="http://libguestfs.org/">virt-v2v</a></dt>
        <dd><span>Migrate guests from one hypervisor to another</span></dd>
      </dl>
      <dl id="p3">

        <dt><a href="http://freeipa.org/">FreeIPA</a></dt>

        <dd><span>Identity, policy and audit management</span></dd>
        <dt><a href="http://virt-manager.org/">Virtual Machine Manager</a></dt>
        <dd><span>Virtualization management from the desktop</span></dd>
      </dl>

       </div>

    </div>

</body>
</html>
